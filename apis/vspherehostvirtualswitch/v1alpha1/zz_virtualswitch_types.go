/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type VirtualSwitchObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type VirtualSwitchParameters struct {

	// List of active network adapters used for load balancing.
	// +kubebuilder:validation:Required
	ActiveNics []*string `json:"activeNics" tf:"active_nics,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +kubebuilder:validation:Optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +kubebuilder:validation:Optional
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +kubebuilder:validation:Optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.
	// +kubebuilder:validation:Optional
	BeaconInterval *float64 `json:"beaconInterval,omitempty" tf:"beacon_interval,omitempty"`

	// Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used only.
	// +kubebuilder:validation:Optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +kubebuilder:validation:Optional
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The managed object ID of the host to set the virtual switch up on.
	// +kubebuilder:validation:Required
	HostSystemID *string `json:"hostSystemId" tf:"host_system_id,omitempty"`

	// Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.
	// +kubebuilder:validation:Optional
	LinkDiscoveryOperation *string `json:"linkDiscoveryOperation,omitempty" tf:"link_discovery_operation,omitempty"`

	// The discovery protocol type. Valid values are cdp and lldp.
	// +kubebuilder:validation:Optional
	LinkDiscoveryProtocol *string `json:"linkDiscoveryProtocol,omitempty" tf:"link_discovery_protocol,omitempty"`

	// The maximum transmission unit (MTU) of the virtual switch in bytes.
	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// The list of network adapters to bind to this virtual switch.
	// +kubebuilder:validation:Required
	NetworkAdapters []*string `json:"networkAdapters" tf:"network_adapters,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +kubebuilder:validation:Optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports that this virtual switch is configured to use.
	// +kubebuilder:validation:Optional
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// The average bandwidth in bits per second if traffic shaping is enabled.
	// +kubebuilder:validation:Optional
	ShapingAverageBandwidth *float64 `json:"shapingAverageBandwidth,omitempty" tf:"shaping_average_bandwidth,omitempty"`

	// The maximum burst size allowed in bytes if traffic shaping is enabled.
	// +kubebuilder:validation:Optional
	ShapingBurstSize *float64 `json:"shapingBurstSize,omitempty" tf:"shaping_burst_size,omitempty"`

	// Enable traffic shaping on this virtual switch or port group.
	// +kubebuilder:validation:Optional
	ShapingEnabled *bool `json:"shapingEnabled,omitempty" tf:"shaping_enabled,omitempty"`

	// The peak bandwidth during bursts in bits per second if traffic shaping is enabled.
	// +kubebuilder:validation:Optional
	ShapingPeakBandwidth *float64 `json:"shapingPeakBandwidth,omitempty" tf:"shaping_peak_bandwidth,omitempty"`

	// List of standby network adapters used for failover.
	// +kubebuilder:validation:Required
	StandbyNics []*string `json:"standbyNics" tf:"standby_nics,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or failover_explicit.
	// +kubebuilder:validation:Optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`
}

// VirtualSwitchSpec defines the desired state of VirtualSwitch
type VirtualSwitchSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualSwitchParameters `json:"forProvider"`
}

// VirtualSwitchStatus defines the observed state of VirtualSwitch.
type VirtualSwitchStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualSwitchObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualSwitch is the Schema for the VirtualSwitchs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vspherejet}
type VirtualSwitch struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualSwitchSpec   `json:"spec"`
	Status            VirtualSwitchStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualSwitchList contains a list of VirtualSwitchs
type VirtualSwitchList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualSwitch `json:"items"`
}

// Repository type metadata.
var (
	VirtualSwitch_Kind             = "VirtualSwitch"
	VirtualSwitch_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VirtualSwitch_Kind}.String()
	VirtualSwitch_KindAPIVersion   = VirtualSwitch_Kind + "." + CRDGroupVersion.String()
	VirtualSwitch_GroupVersionKind = CRDGroupVersion.WithKind(VirtualSwitch_Kind)
)

func init() {
	SchemeBuilder.Register(&VirtualSwitch{}, &VirtualSwitchList{})
}
