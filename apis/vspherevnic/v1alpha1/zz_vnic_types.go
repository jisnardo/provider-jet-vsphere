/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IPv4Observation struct {
}

type IPv4Parameters struct {

	// Use DHCP to configure the interface's IPv4 stack.
	// +kubebuilder:validation:Optional
	DHCP *bool `json:"dhcp,omitempty" tf:"dhcp,omitempty"`

	// IP address of the default gateway, if DHCP is not set.
	// +kubebuilder:validation:Optional
	Gw *string `json:"gw,omitempty" tf:"gw,omitempty"`

	// address of the interface, if DHCP is not set.
	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// netmask of the interface, if DHCP is not set.
	// +kubebuilder:validation:Optional
	Netmask *string `json:"netmask,omitempty" tf:"netmask,omitempty"`
}

type IPv6Observation struct {
}

type IPv6Parameters struct {

	// List of IPv6 addresses
	// +kubebuilder:validation:Optional
	Addresses []*string `json:"addresses,omitempty" tf:"addresses,omitempty"`

	// Use IPv6 Autoconfiguration (RFC2462).
	// +kubebuilder:validation:Optional
	Autoconfig *bool `json:"autoconfig,omitempty" tf:"autoconfig,omitempty"`

	// Use DHCP to configure the interface's IPv4 stack.
	// +kubebuilder:validation:Optional
	DHCP *bool `json:"dhcp,omitempty" tf:"dhcp,omitempty"`

	// IP address of the default gateway, if DHCP or autoconfig is not set.
	// +kubebuilder:validation:Optional
	Gw *string `json:"gw,omitempty" tf:"gw,omitempty"`
}

type VnicObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type VnicParameters struct {

	// Key of the distributed portgroup the nic will connect to
	// +kubebuilder:validation:Optional
	DistributedPortGroup *string `json:"distributedPortGroup,omitempty" tf:"distributed_port_group,omitempty"`

	// UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.
	// +kubebuilder:validation:Optional
	DistributedSwitchPort *string `json:"distributedSwitchPort,omitempty" tf:"distributed_switch_port,omitempty"`

	// ESX host the interface belongs to
	// +kubebuilder:validation:Required
	Host *string `json:"host" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	IPv4 []IPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 []IPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// MAC address of the interface.
	// +kubebuilder:validation:Optional
	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`

	// MTU of the interface.
	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'provisioning'
	// +kubebuilder:validation:Optional
	Netstack *string `json:"netstack,omitempty" tf:"netstack,omitempty"`

	// portgroup to attach the nic to. Do not set if you set distributed_switch_port.
	// +kubebuilder:validation:Optional
	Portgroup *string `json:"portgroup,omitempty" tf:"portgroup,omitempty"`
}

// VnicSpec defines the desired state of Vnic
type VnicSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VnicParameters `json:"forProvider"`
}

// VnicStatus defines the observed state of Vnic.
type VnicStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VnicObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Vnic is the Schema for the Vnics API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vspherejet}
type Vnic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VnicSpec   `json:"spec"`
	Status            VnicStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VnicList contains a list of Vnics
type VnicList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Vnic `json:"items"`
}

// Repository type metadata.
var (
	Vnic_Kind             = "Vnic"
	Vnic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Vnic_Kind}.String()
	Vnic_KindAPIVersion   = Vnic_Kind + "." + CRDGroupVersion.String()
	Vnic_GroupVersionKind = CRDGroupVersion.WithKind(Vnic_Kind)
)

func init() {
	SchemeBuilder.Register(&Vnic{}, &VnicList{})
}
