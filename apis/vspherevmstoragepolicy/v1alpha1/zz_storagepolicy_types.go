/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type StoragePolicyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type StoragePolicyParameters struct {

	// Description of the storage policy.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Tag rules to filter datastores to be used for placement of VMs.
	// +kubebuilder:validation:Required
	TagRules []TagRulesParameters `json:"tagRules" tf:"tag_rules,omitempty"`
}

type TagRulesObservation struct {
}

type TagRulesParameters struct {

	// Whether to include or exclude datastores tagged with the provided tags
	// +kubebuilder:validation:Optional
	IncludeDatastoresWithTags *bool `json:"includeDatastoresWithTags,omitempty" tf:"include_datastores_with_tags,omitempty"`

	// The tag category to select the tags from.
	// +kubebuilder:validation:Required
	TagCategory *string `json:"tagCategory" tf:"tag_category,omitempty"`

	// The tags to use for creating a tag-based vm placement rule.
	// +kubebuilder:validation:Required
	Tags []*string `json:"tags" tf:"tags,omitempty"`
}

// StoragePolicySpec defines the desired state of StoragePolicy
type StoragePolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StoragePolicyParameters `json:"forProvider"`
}

// StoragePolicyStatus defines the observed state of StoragePolicy.
type StoragePolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StoragePolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// StoragePolicy is the Schema for the StoragePolicys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vspherejet}
type StoragePolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StoragePolicySpec   `json:"spec"`
	Status            StoragePolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StoragePolicyList contains a list of StoragePolicys
type StoragePolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StoragePolicy `json:"items"`
}

// Repository type metadata.
var (
	StoragePolicy_Kind             = "StoragePolicy"
	StoragePolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StoragePolicy_Kind}.String()
	StoragePolicy_KindAPIVersion   = StoragePolicy_Kind + "." + CRDGroupVersion.String()
	StoragePolicy_GroupVersionKind = CRDGroupVersion.WithKind(StoragePolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&StoragePolicy{}, &StoragePolicyList{})
}
